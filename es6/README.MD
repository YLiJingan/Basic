## ECMAScript 6入门 学习笔记
[*兼容性*](https://kangax.github.io/compat-table/es6/)		
ES6(ES2015)--IE10+ Chrome FireFox 移动端 NodeJS		


[ES6](http://es6.ruanyifeng.com/#docs/let)		
**src**:书写ES6代码的文件夹，写的js程序都放在这里		
**dist**:利用Babel编译成的ES5代码的文件夹，在HTML页面里需要引入的js 		

### Babel转换器		
ES6转码器，将ES6代码转换为ES5代码，从而在心有环境中执行，不用但是现有环境。		

1. 配置文件 .babelrc	
	`{
		"presets"：[],
		"plugins":[]
	}`		
2. 命令行转码 babel-cli	
3. babel-polyfill	
	babel默认只转换新的JS语法，而不转换新的API。如果想让新的API运行，就必须使用babel-polyfill,为当前环境提供一个垫片。		


### let,const,变量的解构赋值	--index.js 		
#### 块级作用域		
**为什么需要块级作用域**	
1. 内层变量可能会覆盖外层变量	
2. 	用来计数的循环变量泄露为全局变量		

#### ES6块级作用域	
let实际上为JS新增了块级作用域	

#### let		
1. let用来声明变量，变量只在let所在的代码块中有效		
2. let所声明的变量一定要在声明之后使用--即let不存在变量提升	
3. **暂时性死区**		
如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。在语法上称为"暂时性死区"。	
	> 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。	
4. 不允许重复声明		

#### const
1. const声明一个只读的常量。一旦声明，常量的值就不能改变,这就意味着申明变量的时候必须立即初始化，不能留到以后赋值。				
2. const和let一样只在声明的块级作用域中有效，声明的变量也不会提升，同时存在暂时性死区，只能在声明的位置后面使用。	

**ES6声明变量的6中方法: var function let const import class**				

#### 变量的解构赋值		

*两边两边结构必须一样*	
*右边结构必须正确*	
*声明和赋值不能分开(必须在一句话里完成)*	

*从数组和对象中提取值，对变量进行赋值，这种称为解构*	
解构赋值允许指定默认值。	
1. 数组的解构赋值		
	如果解构不成功，变量的值等于undefined.		
	不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组，解构依然可以成功。		
	解构赋值允许指定默认值，在ES6内部使用严格相等运算符，判断一个位置是否有值。故只有数组成员严格等于Undefined，默认值才会生效。	
2. 对象的解构赋值		
	对象的属性没有次序，变量必须与属性同名，才能取到正确的值。		
	对象的解构赋值是内部机制，是先找到同名属性，额然后再赋值给对应的变量，真正被赋值的是后者，而不是前者。	
3. 用途		
	变换变量的值	
	从函数返回多个值	


### 字符串的扩展	--string_model.js 		
#### JS字符6种表示方法
	'\z' === 'z'	
	'\172' === 'z'	
	'\x7A' === 'z'
	'\u007A' === 'z'
	'\u{7A}' === 'z'		

#### for...of	
	遍历字符串，可以识别大于0xFFFF,传统的for循环无法识别。	

#### include() startsWith() endsWith()	
1. includes():返回布尔值，表示是否找到了参数字符串	
2. startsWith():返回字符串，表示参数字符串是否在原字符串的头部	
3. endsWith():返回布尔值，表示参数字符串是否在原字符串的尾部	
	这三个方法都支持第二个参数，表示开始搜索的位置。	

#### repeat()	
1. reapt()方法返回一个新字符串，表示将原字符串重复n次。		
	参数如果是小数，会被取整;若参数是负数或者是Infinity，会报错。	

#### padStart() padEnd()	
* 字符串补全长度的功能，如果某个字符串不够指定长度，会在头部或尾部补全。		
* padStart()用于头部补全，padEnd()用于尾部补全。	
* 接受两个参数，第一个用来指定字符串的最小长度，第二个长度是用来补全字符串的字符串。如果原字符串的长度，等于或者大于指定的最小长度，则返回原字符串。如果省略第二个参数，默认使用空格补全长度.	
	**用途**:为数值补全指定位数，提示字符串格式	

#### 模板字符串	
 * 模板字符串就是增强的字符串，用反引号(`)标识。可以用作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。			
* 在模板字符串中使用反斜杠需要使用反引号进行转译，如果使用模板字符串表示多行字符串，则所有的空格和缩进都会被保留在输出之中。
***	
**模板字符串中嵌入变量，需要将变量名写在${}之中**
**{}大括号中可以放入任意的JS表达式，进行运算，以及引用对象属性**	
**模板字符串之中还能调用函数**	
**如果大括号中的只不是字符串，将按照一般的规则转换为字符串**		

---		
### 正则的扩展		
### 数值的扩展	

### 函数的扩展	--function.js 		
#### 箭头函数	
*只有一个参数，()可以省略*	
*只有一个return,{}可以省略* 	

* 参数扩展(rest参数)	
ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。	
Rest Parameter必须是最后一个参数。	
* 默认参数
不传该参数使用默认参数，出入该参数覆盖默认参数。	

### 数组的扩展	--array.js 	
* map reduce filter forEach		

### ES6 class  --class.js
* class关键字,构造器constructor和类分开了。				
* class里直接加方法，不需要再使用prototype。方法直接写方法名即可，不需要加function	
* 默认是严格模式	
* 如果没有显示定义constructor,一个空的constructor方法会被默认添加。constructor方法默认返回实例对象(即this)		


* 继承
	extends		
	* 子类必须在constructor方法中调用super方法，否则新建实例时会报错。	
	* 在子类的构造函数中，只有调用super之后，才可以使用this关键字。	

* 面向对象应用-react	
	组件化，每一个组件就是一个Class	
	JSX			

### JSON  --json.js
*json标准写法:只能用双引号，所有的key都必须用引号包起来*		
* JSON对象
	JSON.stringify()	
	JSON.parse()		
* 简写(key和value一样，方法)


### Promise对象  --promise.js
* 异步请求、同步请求
	* 异步：可以同时进行多个操作，操作之间互不影响  ajax     代码复杂
	* 同步：同时只能做一件事，必须等前边的完成之后才能进行    代码简单







